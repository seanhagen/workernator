package library

import (
	"context"
	"errors"
	"fmt"
	"io"
	"os"
	"os/exec"
	"sync"
	"time"

	"github.com/rs/xid"
	"go.uber.org/zap"
)

// JobInfo contains information about a job, whether it's running or
// finished.
type JobInfo struct {
	ID        string
	Status    JobStatus
	Command   string
	Arguments []string
	Error     error
	Started   time.Time
	Ended     time.Time
}

// Job contains information about a running job, and also provides the
// ability to wait for a job to finish or to stop the job early.
type Job struct {
	JobInfo

	cmd    *exec.Cmd
	done   context.Context
	cancel context.CancelFunc

	lock sync.RWMutex

	outputPath string
	stdout     *os.File
	stderr     *os.File
}

// NewJob ...
func NewJob(ctx context.Context, outputDir string, command string, args ...string) (*Job, error) {
	ctx, cancel := context.WithCancel(ctx)
	id := xid.New()

	jobOutputDir := outputDir + "/" + id.String()
	if err := os.MkdirAll(jobOutputDir, 0755); err != nil {
		return nil, fmt.Errorf("unable to create job output directory: %w", err)
	}

	stdoutFile, err := os.OpenFile(jobOutputDir+"/output", os.O_CREATE|os.O_WRONLY|os.O_TRUNC|os.O_SYNC, 0644)
	if err != nil {
		return nil, fmt.Errorf("unable to create file to capture output: %w", err)
	}

	stderrFile, err := os.OpenFile(jobOutputDir+"/error", os.O_CREATE|os.O_WRONLY|os.O_TRUNC|os.O_SYNC, 0644)
	if err != nil {
		return nil, fmt.Errorf("unable to create file to capture errors: %w", err)
	}

	cmd := exec.Command(command, args...)
	cmd.Stdout = stdoutFile
	cmd.Stderr = stderrFile

	if err := cmd.Start(); err != nil {
		cancel()
		return nil, err
	}

	job := &Job{
		JobInfo: JobInfo{
			ID:     id.String(),
			Status: Running,

			Command:   command,
			Arguments: args,

			Started: time.Now(),
		},
		cmd:    cmd,
		done:   ctx,
		cancel: cancel,
		lock:   sync.RWMutex{},

		outputPath: outputDir,
		stdout:     stdoutFile,
		stderr:     stderrFile,
	}

	go job.closeOutputsWhenJobDone()
	go job.waitForFinish()

	return job, nil
}

// Stop forceably stops the job ( by killing it ), returning the error
// ( if any ) returned from the system when trying to kill the
// job.
func (j *Job) Stop() error {
	err := j.cmd.Process.Kill()
	<-j.done.Done()
	return err
}

// Wait is a function that blocks until the job is complete, at
// which point it returns the error ( if any ) generated by running
// the command.
func (j *Job) Wait() error {
	<-j.done.Done()
	return j.Error
}

// Info returns a JobInfo struct containing the static information
// about this job.
func (j *Job) Info() JobInfo {
	return j.JobInfo
}

// Finished returns true if the end time for the job has been set.
func (j *Job) Finished() bool {
	var ended time.Time
	j.lock.RLock()
	ended = j.Ended
	j.lock.RUnlock()
	return !ended.IsZero()
}

// GetOutput ...
func (j *Job) GetOutput() (io.ReadCloser, error) {
	path := j.outputPath + "/" + j.ID + "/output"
	output, err := os.OpenFile(path, os.O_RDONLY, 0444)
	if err != nil {
		return nil, err
	}

	read, write := io.Pipe()
	go j.pipeOutput(output, write)
	return read, nil
}

// pipeOutput is meant to be launched as a goroutine so that it can
// read from the provided file and write to the io pipe provided. If
// the job hasn't finished, it will wait until it has before
// exiting. This provides the 'tail' functionality.
func (j *Job) pipeOutput(file *os.File, writeTo *io.PipeWriter) {
	var lastSize int64
	buf := make([]byte, 1024)

	for {
		fi, err := file.Stat()
		if err != nil {
			x := fmt.Errorf("unable to stat file: %w", err)
			_ = writeTo.CloseWithError(x)
			return
		}

		if fi.Size() > lastSize {
			n, err := file.Read(buf)

			// if we read anything, first write it to our pipe
			if n > 0 {
				lastSize += int64(n)
				_, err = writeTo.Write(buf[:n])
				if err != nil {
					_ = writeTo.CloseWithError(err)
					return
				}
			}

			if err == nil && j.Finished() {
				_ = writeTo.CloseWithError(io.EOF)
				return
			}

			// unable to read from the file because we've reached the end?
			if errors.Is(err, io.EOF) {
				if j.Finished() {
					_ = writeTo.CloseWithError(io.EOF)
					return
				}
				goto wait
			}

			if err != nil {
				_ = writeTo.CloseWithError(err)
			}
		}

	wait:
		time.Sleep(time.Millisecond * 200)
	}
}

// closeOutputsWhenJobDone waits for the context to signal the job is
// complete, then syncs and closes both the stdout file and the stderr
// file.
func (j *Job) closeOutputsWhenJobDone() {
	<-j.done.Done()

	if err := j.stdout.Sync(); err != nil {
		zap.L().Error("unable to sync job stdout file", zap.Error(err))
	}

	if err := j.stdout.Close(); err != nil {
		zap.L().Error("unable to close job stdout file", zap.Error(err))
	}

	if err := j.stderr.Sync(); err != nil {
		zap.L().Error("unable to sync job stderr file", zap.Error(err))
	}

	if err := j.stderr.Close(); err != nil {
		zap.L().Error("unable to close job stderr file", zap.Error(err))
	}
}

// waitForFinish ...
func (j *Job) waitForFinish() {
	defer j.cancel()
	cmdErr := j.cmd.Wait()
	exitCode := j.cmd.ProcessState.ExitCode()

	j.lock.Lock()
	defer j.lock.Unlock()
	j.Ended = time.Now()

	// job wasn't killed, but failed for some reason
	if cmdErr != nil && exitCode != statusOK {
		j.Error = cmdErr
		j.Status = Failed
		return
	}

	// no error, but not 'ok' exit code
	if cmdErr == nil && exitCode != statusOK {
		j.Error = fmt.Errorf("exited with status %v", exitCode)
		j.Status = Failed
		return
	}

	// if the job was killed, the exitCode will equal statusKilled (-1)
	if exitCode == statusKilled {
		j.Error = cmdErr
		j.Status = Stopped
		return
	}

	// if we got here, the job should have exited successfully
	j.Status = Finished

	// if there was an error, even though the exit code is OK, we should
	// keep it. 99 out of 100, this is just assigning a nil error; but
	// that one time it's handy to have it around still.
	j.Error = cmdErr

}
