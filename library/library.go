package library

import (
	"context"
	"fmt"
	"os/exec"
	"sync"
	"time"
)

const (
	// this is a potential status code returned by
	// (*exec.Cmd).ProcessState.ExitCode(); it's -1 when a job is still
	// running or when it was terminated via a signal
	statusKilled = -1

	// this is the status code returned in UNIX when a program exits
	// successfully
	statusOK = 0
)

// JobStatus is used to define the potential statuses for a job
type JobStatus int

const (
	// Unknown is the default value, and should be treated as an error
	Unknown JobStatus = iota
	// Running means the job is still executing
	Running JobStatus = iota
	// Failed means the job returned an error and did not complete successfully
	Failed JobStatus = iota
	// Finished means the job completed successfully
	Finished JobStatus = iota
	// Stopped means the job was stopped/killed before it could complete
	Stopped JobStatus = iota
)

// NewErrInvalidID builds a custom ErrInvalidID and returns it
func NewErrInvalidID(id string, err error) error {
	return ErrInvalidID{id, err}
}

// NewErrNoJobForID builds a custom ErrNoJobForID and returns it
func NewErrNoJobForID(id string) error {
	return ErrNoJobForID{id}
}

// ErrInvalidID is a custom error for when JobStatus(), StopJob(), or
// GetJobOutput() is called with an ID that is not a valid xid
type ErrInvalidID struct {
	id  string
	err error
}

func (inv ErrInvalidID) Error() string {
	return fmt.Sprintf("'%v' is not a valid job id: %v", inv.id, inv.err)
}

// ErrNoJobForID is a custom error for when JobStatus(), StopJob(), or
// GetJobOutput() is called with an ID that the manager doesn't know
// about
type ErrNoJobForID struct {
	id string
}

func (no ErrNoJobForID) Error() string {
	return fmt.Sprintf("no job found for id '%v'", no.id)
}

// Job contains information about a running job, and also provides the
// ability to wait for a job to finish or to stop the job early.
type Job struct {
	JobInfo

	cmd  *exec.Cmd
	done context.Context
	lock sync.RWMutex
}

// SetCommand is used by the manager to set the *exec.Cmd run by this
// job.
func (j *Job) SetCommand(cmd *exec.Cmd) {
	j.lock.Lock()
	j.cmd = cmd
	j.lock.Unlock()
}

// SetContext is used by the manager to set the context.Context used
// when waiting for a job to complete.
func (j *Job) SetContext(ctx context.Context) {
	j.lock.Lock()
	j.done = ctx
	j.lock.Unlock()
}

// SetFinished ...
func (j *Job) SetFinished(cmdErr error, exitCode int) {
	j.lock.Lock()
	defer j.lock.Unlock()
	j.Ended = time.Now()

	// if the job was killed, the exitCode will equal statusKilled (-1)
	if exitCode == statusKilled {
		j.Error = cmdErr
		j.Status = Stopped
		return
	}

	// job wasn't killed, but failed for some reason
	if cmdErr != nil {
		j.Error = cmdErr
		j.Status = Failed
		return
	}

	// no error, but not 'ok' exit code
	if cmdErr == nil && exitCode != statusOK {
		j.Error = fmt.Errorf("exited with status %v", exitCode)
		j.Status = Failed
		return
	}

	// if we got here, the job should have exited successfully
	j.Status = Finished
}

// Stop forceably stops the job ( by killing it ), returning the error
// ( if any ) returned from the system when trying to kill the
// job. This should be set by the job manager.
func (j *Job) Stop() error {
	err := j.cmd.Process.Kill()
	<-j.done.Done()
	return err
}

// Wait is a function that blocks until the job is complete, at
// which point it returns the error ( if any ) generated by running
// the command. This should be set by the job manager.
func (j *Job) Wait() error {
	<-j.done.Done()
	return j.Error
}

// Info  ...
func (j *Job) Info() JobInfo {
	return j.JobInfo
}

// Finished ...
func (j *Job) Finished() bool {
	var ended time.Time
	j.lock.RLock()
	ended = j.Ended
	j.lock.RUnlock()
	return !ended.IsZero()
}

// JobInfo contains information about a job, whether it's running or
// finished.
type JobInfo struct {
	ID        string
	Status    JobStatus
	Command   string
	Arguments []string
	Error     error
	Started   time.Time
	Ended     time.Time
}
